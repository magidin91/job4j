1.  Создать объект User c полями и перекрытым методом finalize
public class User {
    private final String name;
    private final String surname;
    private int age;
...
}
2. Создать несколько объектов User и руками рассчитать сколько он будет занимать памяти.
new User("a", "b", 20)

JVM хранит для каждого объекта:
- Заголовок объекта;
- Память для примитивных типов;
- Память для ссылочных типов;
- Смещение/выравнивание

 Каждый заголовок для большинства JVM(Hotspot, openJVM) состоит из двух машинных слов.
Если речь идет о 32-х разрядной системе, то размер заголовка — 8 байт, если речь о 64-х разрядной системе, то соответственно — 16 байт.

Объект User(62 разрядная система):
Заголовок=16 байт
Две ссылки на String = 2*8=16 байт(Размер ссылки в JVM зависит от ее разрядности. В 32-х разрядных JVM размер ссылки обычно 4 байта, а в 64-х разрядных — 8 байт.)
Поле int = 4 байта
Выравнивание=4 байта
Итого=40 байт

+ Cами два объекта String
Объект String:
private final byte[] value;
private final byte coder;
private int hash;
private boolean hashIsZero;
Заголовок=16 байт
Ссылка на массив = 8 байт
Поле byte=1 байт
Поле int=4 байта
Поле boolean=1 байт (примерно)
Выравнивание=2 байта
Итого=32 байта

+ Объект массива byte:
Заголовок: 16 байт + 4 байта на длину массива == 20 байт
Каждый символ весит 2 байта. 2*1=2 байта
Выравнивание=2 байта
Итого=24 байта

Объект String = 56 байт, 2 объекта String = 112 байт.

===Итого, объект User = 112+40=152 байта===


3. Нужно найти информацию. Сколько памяти занимает пустой объект без полей.
Пустой объект состоит только из заголовка.
Соответственно пустой объект весит 8 или 16 байт.(зависит от разрядности системы)

4. Добиться состояния, когда виртуальная машина вызывает сборщик мусора самостоятельно. За счет ключей xmx.
Используя ключ -Xmx4m, устанавливаю максимальный размер памяти для JVM = 4 мегабайта.
Затем в цикле создаю объекты без ссылок, когда память начинает заканчиваться, GC осуществляет сборку недосягаемых мусорных объектов.
